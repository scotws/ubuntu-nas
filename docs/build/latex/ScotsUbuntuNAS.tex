%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Scot's Ubuntu NAS Documentation}
\date{Jun 15, 2019}
\release{0.1.0beta}
\author{Scot W. Stevenson}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
In 2019, the motherboard of my FreeNAS server died. Instead of simply replacing
it and continuing, I decided to switch to a self-created NAS based on Ubuntu
Server 18.04 LTS with ZFS and containers (Docker). This document is based on the
line-by line notes I made, and provided for anybody who is thinking about
building such a system themselves.

However, \sphinxstylestrong{you probably don’t want to do this}. I’m no server expert, this
machine is set up for a very special use case and threat scenario, and this text
doesn’t even attempt to provide a complete guide. One reason I wrote it, in
fact, is to learn reStructured text, Sphinx, and Read the Docs for other
projects.

Still, if you feel you must, by all means read on.

\begin{sphinxadmonition}{warning}{Warning:}
Follow the instructions and suggestions in this text at your own
risk. There is a very real chance that you could lose data, even all of
it. I take no responsibility for anything bad or even mildly irritating
that happens.
\end{sphinxadmonition}
\begin{description}
\item[{If you need more hand-holding:}] \leavevmode
\sphinxstylestrong{FreeNAS} (\sphinxurl{http://freenas.org}) comes with extensive documentation and a
very helpful community. It served me well for years, and if I hadn’t
being trying to learn more about servers and containers, I would have stayed
with it. FreeNAS comes with the ZFS file system as well.

\item[{If you need \sphinxstyleemphasis{lots} more hand-holding:}] \leavevmode
There are a bunch of \sphinxstylestrong{commercial NAS} vendors, for example Synology or
QNAP. Usually, you just need to add the drive and the setup does the
rest; however, they rarely come with ZFS.

\item[{If you need more power and features:}] \leavevmode
\sphinxstylestrong{Ansible-NAS} (\sphinxurl{https://github.com/davestephens/ansible-nas}) is a far more
ambitious variant of a Ubuntu NAS by Dave Stephens. As the name says, it
makes extensive use of Ansible for configuration, and comes with
a higher level of configuration. Full disclosure: I have contributed to the
documentation.

\end{description}

License: CC-BY-SA-4.0 (\sphinxurl{https://creativecommons.org/licenses/by-sa/4.0/})


\chapter{Goals}
\label{\detokenize{goals:goals}}\label{\detokenize{goals::doc}}
This introduces the basic setup in the house where the NAS will be installed,
the other machines on the network, and some of the names and addresses used.

\begin{sphinxadmonition}{note}{Note:}
Some of this information differs from the actual setup for security
reasons. It is possible that this has created inconsistencies at some
points when I didn’t pay attention. Please report these as errors.
\end{sphinxadmonition}


\section{House overview}
\label{\detokenize{goals:house-overview}}
The NAS is part of a computer setup in a single-family house with four human
users and two cats. The local network is not accessible from the outside.
Internet connection is through a DSL modem, which also (currently) serves as the
DHCP server. The local DNS connection goes through PiHole (\sphinxurl{https://pi-hole.net/})
on a Raspberry Pi.

There are also Windows computers in the house, mainly for gaming, but they are
considered \sphinxstylestrong{untrusted} by default and may not access the NAS.

Various people work at various strange times in the house, so the Raspberry Pi
and the NAS itself are on all the time. Also, cats have weird sleep schedules.


\section{Network}
\label{\detokenize{goals:network}}
To keep things simple, all machines will be considered to be part of the IPv4
local network 192.168.13.0/24. For the purpose of this document, the server’s
name will be \sphinxstylestrong{home} and the main computer we work from \sphinxstylestrong{chell}, after the
character in the Valve computer game. Most machines are assigned \sphinxstyleemphasis{static
addresses}. In particular:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline

home
&
192.168.13.2
&
NAS
&
Ubuntu Server
\\
\hline
chell
&
192.168.13.20
&
user PC
&
Ubuntu Desktop
\\
\hline
worker
&
192.168.13.21
&
user PC
&
Ubuntu Desktop
\\
\hline
mediator
&
192.168.13.22
&
laptop
&
MacOS
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

There are also various other machines such as mobile phones, Chromebooks and
iPads that connect to the network but are not relevant here.

In practice, most user addressing uses mDNS (zero configuration) internally. As
we will see later, this means we access the NAS with commands such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssh} \PYG{n}{home}\PYG{o}{.}\PYG{n}{local}
\end{sphinxVerbatim}

This has the pleasant side effect of automatically locking out the Windows
machines, which do not support zero configuration out of the box.


\section{NAS duties}
\label{\detokenize{goals:nas-duties}}
The NAS in this house is expected to provide the following services, in order of
importance:
\begin{itemize}
\item {} 
Storage for documents and media, especially family photos

\item {} 
Auto backup for the users’ data from Linux and MacOS machines (not: Windows)

\item {} 
Low-traffic Emby server (usually only one user)

\item {} 
Serve NFS shares to one other Ubuntu machine chell

\item {} 
Allow experimenting with containers and virtual machines

\end{itemize}

In the future, other functions might be added such as game server or a family
chat bot.

The storage function has the highest priority, especially for family photos,
which are considered irreplaceable. As such, they must be protected from bitrot
by a \sphinxstyleemphasis{self-healing file system}. In practice, this means either ZFS or Btrfs. ZFS
has been in production longer, and Btrfs is far less battle-tested and comes
with various warnings about how things are (still) not production ready.
Therefore, ZFS is the main mass storage file system for the NAS.

\begin{sphinxadmonition}{important}{Important:}
At the most basic level, this NAS is a life-support system for
ZFS.
\end{sphinxadmonition}

The other functions are secondary.


\section{Threat assessment}
\label{\detokenize{goals:threat-assessment}}
The NAS is operating in a low-threat environment. It is not accessible from the
internet, there is especially no VPN or other (known) way to reach it from
outside. The machine itself is physically secured in the sense that if bad
people are in my house, the threat to the NAS will not be my first concern.
Still, the setup will follow \sphinxstyleemphasis{best practices} as far as possible with hardening
and firewall.

The main threat here is \sphinxstylestrong{data loss} through hard drive failure, power outage,
cat intervention, or other such factors. The main strategy here is \sphinxstyleemphasis{multiple
redundant backups}, some of them off-site.

The secondary threat is \sphinxstylestrong{user screw-ups}, especially accidentally deleting
data.


\section{NAS overview}
\label{\detokenize{goals:nas-overview}}
Though the NAS can be accessed directly by the console, mostly it will be
administered from the computer chell. This functions as a \sphinxstylestrong{jump server} - other
machines will be barred from accessing the NAS as much as possible. Since chell
is powered down when not in use, this means that accessing the NAS through the
network using ssh is usually not possible at all.


\chapter{Hardware}
\label{\detokenize{hardware:hardware}}\label{\detokenize{hardware::doc}}
Most of the hardware was taken from the previous FreeNAS install.


\section{Motherboard}
\label{\detokenize{hardware:motherboard}}
The main difference is the new motherboard, a \sphinxhref{https://www.supermicro.com/products/motherboard/Xeon/D/X10SDV-4C-7TP4F.cfm}{Supermicro X10SDV-4C-7TP4F}
Out of the box, you can attach \sphinxstylestrong{20 SATA 3.0 drives} and install \sphinxstylestrong{one M.2 NVMe
PCIe 3.0} memory stick. This is currently not used, as are the \sphinxstylestrong{two SFP+ 10
GBit Ethernet} ports. They are for later expansions.

The processor is an \sphinxstylestrong{Intel Xeon D-1518 4/8 core 2.20 GHz}, which is overkill
for current use but should be powerful enough for later virtual machines.


\section{Drives}
\label{\detokenize{hardware:drives}}
In this first incarnation, the \sphinxstylestrong{root file system} for Ubuntu 18.04 LTS is
on a 120 GB Intel 540S SSD. Root on ZFS is still too complicated for this
project.

\begin{sphinxadmonition}{note}{Note:}
At time of writing, ZFS on Linux 0.8 was not yet integrated to the
Ubuntu kernel, this is using 0.7.9-3ubuntu6
\end{sphinxadmonition}

The \sphinxstylestrong{mass storage} was inherited from the FreeNAS build and consists of one
ZFS pool (“tank”) constructed from two RaidZ VDEVs in 3/3/3 TB and 4/4/4 TB
configuration. The total size is 14 TB on six drives.


\section{Extra cooling fan}
\label{\detokenize{hardware:extra-cooling-fan}}
The X10SDV-4C-7TP4F is shipped without a CPU cooler, which doesn’t work. Instead
of buying an extra cooler and replacing the passive heat sink, we install a
jury-rigged fan that blows air on the heat sink.


\section{Other hardware}
\label{\detokenize{hardware:other-hardware}}\begin{description}
\item[{\sphinxstylestrong{RAM:} 2 x 8 GB DDR4 ECC RAM}] \leavevmode
This is left over from a different project. As finances allow, these
will be replaces by 4 x 16 GB ECC RAM for a total of 64 GB. Though ZFS
loves RAM and the maximum for the board is 128 GB, this should be enough
for our use.

\item[{\sphinxstylestrong{Graphics:} In contrast to the usual setup with servers, there is an old 4:3}] \leavevmode
monitor attached with VGA. Also, there is keyboard. Both are in the same
room as the main computer. This means we can do stuff directly at the
console which otherwise would require ssh.

\item[{\sphinxstylestrong{Case:} Fractal Design Define R5 White FD-CA-DEF-R5-WT}] \leavevmode
Chosen for the soundproofing, provides easy storage for eight HDs and
two SSDs.

\end{description}

\sphinxstylestrong{UPS:} APC Back-UPS 700VA BX700U-GR

\sphinxstylestrong{Power:} Seasonic SSR-450RM Active PFC G-450 (450W, ATX 12V)


\section{IPMI}
\label{\detokenize{hardware:ipmi}}
The motherboard comes with IPMI enabled through either a separate network
interface or shared with on of the normal 1 GB Ethernet connections. We really
don’t need it in our case, but it’s there and we have to secure it.

In our set, IPMI gets an address at boot via DHCP, for example something like
192.168.13.117. Write it down from the boot screen and then when the server is
powered up, use a web browser to access the IPMI interface.

The most important thing is to change the default Supermicro user name and
password from ADMIN/ADMIN do something different.


\subsection{Links}
\label{\detokenize{hardware:links}}
\sphinxurl{https://www.servethehome.com/basic-bmc-and-ipmi-management-security-practices/}


\section{BIOS}
\label{\detokenize{hardware:bios}}
Make sure that \sphinxstylestrong{virtualization support} is enabled. Also, the \sphinxstylestrong{boot order}
can be tricky to get right.


\section{LSI interface}
\label{\detokenize{hardware:lsi-interface}}
The 16 SATA port interface card will show its own boot screen during startup. We
do not need to change anything. Note the X10SDV-4C-7TP4F only includes the
“dumb” IT mode, so we don’t have to flash the BIOS to avoid hardware RAID
configurations.


\chapter{Ubuntu Server}
\label{\detokenize{os:ubuntu-server}}\label{\detokenize{os::doc}}
We use Ubuntu Server 18.04 LTS which is supported until 2023. We download it the
normal way from \sphinxurl{https://www.ubuntu.com/download/server} . We check to make sure
that the file is intact by running

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ea6ccb5b57813908c006f42f7ac8eaa4fc603883a2d07876cf9ed74610ba2f53 *ubuntu\PYGZhy{}18.04.2\PYGZhy{}live\PYGZhy{}server\PYGZhy{}amd64.iso}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\textbar{}} \PYG{n}{sha256sum} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{check}
\end{sphinxVerbatim}

which gives you an OK. Move to USB stick with \sphinxtitleref{Startup Disk Creator}.


\section{Memory Test}
\label{\detokenize{os:memory-test}}
Before we can proceed, we use the Ubuntu USB stick’s memory test function to
make sure that our RAM is okay.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{memtest}.jpg}\hspace*{\fill}}

This can take hours.


\section{Basic installation}
\label{\detokenize{os:basic-installation}}
After the memory test, reboot and start installing the server.

\begin{sphinxadmonition}{warning}{Warning:}
During the install, do not select the option to install Docker.
This will install Docker into a snap, which will then not work correctly.
In fact, you probably want to avoid all snaps.
\end{sphinxadmonition}

Afterwards, we update the system and reboot to be sure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{update}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{upgrade}
\PYG{n}{sudo} \PYG{n}{reboot}
\end{sphinxVerbatim}

The name of the user we install as will be \sphinxcode{\sphinxupquote{user1}} in our examples.

\begin{sphinxadmonition}{note}{Note:}
Most of the examples here have \sphinxcode{\sphinxupquote{sudo}} in front of them to mark that
they have to be executed by the superuser. If you tire of this (and you
will), use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{su} \PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

to switch to root permanently. Remember to \sphinxcode{\sphinxupquote{exit}} as soon as possible.
\end{sphinxadmonition}


\chapter{Livepatch}
\label{\detokenize{livepatch:livepatch}}\label{\detokenize{livepatch::doc}}
Canonical Livepatch automatically updates some parts of the kernel without
rebooting.

Log into \sphinxurl{https://ubuntu.com/livepatch} and get the id number. On the machine,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{snap} \PYG{n}{install} \PYG{n}{canonical}\PYG{o}{\PYGZhy{}}\PYG{n}{livepatch}
\PYG{n}{sudo} \PYG{n}{canonical}\PYG{o}{\PYGZhy{}}\PYG{n}{livepatch} \PYG{n}{enable} \PYG{o}{\PYGZlt{}}\PYG{n}{NUMBER}\PYG{o}{\PYGZgt{}}
\PYG{n}{canonical}\PYG{o}{\PYGZhy{}}\PYG{n}{livepatch} \PYG{n}{status} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{verbose}
\end{sphinxVerbatim}

We don’t do this on chell because we reboot the thing all the time anyway.


\section{Links}
\label{\detokenize{livepatch:links}}\begin{itemize}
\item {} 
\sphinxurl{http://blog.dustinkirkland.com/2016/10/canonical-livepatch.html}

\end{itemize}


\chapter{Services}
\label{\detokenize{services:services}}\label{\detokenize{services::doc}}

\section{mDNS (Avahi)}
\label{\detokenize{services:mdns-avahi}}
Zero configuration, also known as mDNS or Avahi on Linux, is not installed by
default with Ubuntu Server. This means we can’t access \sphinxcode{\sphinxupquote{.local}} addresses.
This is our primary main way of talking to machines. We will want to do this via
the console.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{avahi}\PYG{o}{\PYGZhy{}}\PYG{n}{daemon}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{avahi}\PYG{o}{\PYGZhy{}}\PYG{n}{utils}
\end{sphinxVerbatim}

Note we will have to punch a hole in the firewall later for \sphinxcode{\sphinxupquote{UDP 5353}} for
local machines.

To get a list of machines on the network, use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{avahi}\PYG{o}{\PYGZhy{}}\PYG{n}{browse} \PYG{o}{\PYGZhy{}}\PYG{n}{a}
\end{sphinxVerbatim}


\subsection{Links}
\label{\detokenize{services:links}}\begin{itemize}
\item {} 
\sphinxurl{https://kb.iweb.com/hc/en-us/articles/360005117952-Guide-to-Multicast-DNS-mDNS-security-issues}

\end{itemize}


\section{Network}
\label{\detokenize{services:network}}
We want home to have a static address. In fact, our network is small and
unchanging enough we can use static addresses for a lot of things.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{vi} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{netplan}\PYG{o}{/}\PYG{l+m+mi}{50}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{init}\PYG{o}{.}\PYG{n}{yaml}
\end{sphinxVerbatim}

We change this to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{network}\PYG{p}{:}
    \PYG{n}{ethernets}\PYG{p}{:}
        \PYG{n}{eno1}\PYG{p}{:}
            \PYG{n}{addresses}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.2}\PYG{o}{/}\PYG{l+m+mi}{24}\PYG{p}{]}
            \PYG{n}{gateway4}\PYG{p}{:} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.1}
            \PYG{n}{nameservers}\PYG{p}{:}
              \PYG{n}{addresses}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.8}\PYG{p}{,}\PYG{l+m+mf}{8.8}\PYG{o}{.}\PYG{l+m+mf}{8.8}\PYG{p}{]}
            \PYG{n}{dhcp4}\PYG{p}{:} \PYG{n}{no}
        \PYG{n}{eno2}\PYG{p}{:}
            \PYG{n}{dhcp4}\PYG{p}{:} \PYG{n}{true}
        \PYG{n}{eno7}\PYG{p}{:}
            \PYG{n}{dhcp4}\PYG{p}{:} \PYG{n}{true}
        \PYG{n}{eno8}\PYG{p}{:}
            \PYG{n}{dhcp4}\PYG{p}{:} \PYG{n}{true}
    \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Despite the scary text in the file, this survives reboots every time. Here,
restart the network. From the terminal, execute

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{netplan} \PYG{n}{apply}
\end{sphinxVerbatim}

In the router, make sure that we get the same address every time via DHCP for
this machine.


\subsection{Links}
\label{\detokenize{services:id1}}\begin{itemize}
\item {} 
\sphinxurl{https://websiteforstudents.com/configure-static-ip-addresses-on-ubuntu-18-04-beta/}

\item {} 
\sphinxurl{https://www.ostechnix.com/how-to-configure-ip-address-in-ubuntu-18-04-lts/}

\end{itemize}


\section{SSH}
\label{\detokenize{services:ssh}}
Though we use the console for lots of stuff, in practice, we’ll want to be able
to access the server via ssh. Remember chell is the jump server for home, other
machines should not be able to access it.

We change a bunch of options to “harden” the server. We start by editing
\sphinxcode{\sphinxupquote{/etc/ssh/sshd\_config}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AllowUsers} \PYG{n}{user1}
\PYG{n}{ClientAliveCountMax} \PYG{l+m+mi}{0}
\PYG{n}{ClientAliveInterval} \PYG{l+m+mi}{300}
\PYG{n}{IgnoreRhosts} \PYG{n}{yes}
\PYG{n}{LoginGraceTime} \PYG{l+m+mi}{2}\PYG{n}{m}
\PYG{n}{MaxAuthTries} \PYG{l+m+mi}{5}
\PYG{n}{MaxSessions} \PYG{l+m+mi}{3}
\PYG{n}{PermitEmptyPasswords} \PYG{n}{no}
\PYG{n}{PermitRootLogin} \PYG{n}{no}
\PYG{n}{Port} \PYG{l+m+mi}{2019}
\PYG{n}{PrintMotd} \PYG{n}{yes}
\PYG{n}{Protocol} \PYG{l+m+mi}{2}
\PYG{n}{X11Forwarding} \PYG{n}{no}
\end{sphinxVerbatim}

Note that we change the default port (to the year this was written). We’ll go
over some of these later when we take a look at the firewall. Then restart the
ssh demon.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{systemctl} \PYG{n}{restart} \PYG{n}{ssdh}
\end{sphinxVerbatim}

We don’t want to let anybody log in with just their password, instead, we need
them to have \sphinxstyleemphasis{public keys} generated on chell. We will then copy it over from
there to home. Don’t use a passphrase when prompted:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssh}\PYG{o}{\PYGZhy{}}\PYG{n}{keygen}
\PYG{n}{cat} \PYG{o}{.}\PYG{n}{ssh}\PYG{o}{/}\PYG{n}{id\PYGZus{}rsa}\PYG{o}{.}\PYG{n}{pub}
\PYG{n}{ssh}\PYG{o}{\PYGZhy{}}\PYG{n}{copy}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{id} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mi}{2019} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{o}{.}\PYG{n}{ssh}\PYG{o}{/}\PYG{n}{id\PYGZus{}rsa}\PYG{o}{.}\PYG{n}{pub} \PYG{n}{user1}\PYG{n+nd}{@home}\PYG{o}{.}\PYG{n}{local}
\end{sphinxVerbatim}

On home, we then edit \sphinxcode{\sphinxupquote{/etc/sshd\_config}} to include:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PubkeyAuthentication} \PYG{n}{yes}
\PYG{n}{PasswordAuthentication} \PYG{n}{no}
\end{sphinxVerbatim}

Restart again. Because logging in with a different port and all of that gets old
fast, we create a file \sphinxcode{\sphinxupquote{\textasciitilde{}/.ssh/config}} on home with the content:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Host} \PYG{n}{home}
    \PYG{n}{Hostname} \PYG{n}{home}\PYG{o}{.}\PYG{n}{local}
    \PYG{n}{User} \PYG{n}{user1}
    \PYG{n}{Port} \PYG{l+m+mi}{2019}
\end{sphinxVerbatim}

Now we can just login from chell with \sphinxcode{\sphinxupquote{ssh home}} as user1. We cannot just log
in via password. Remember chell is the jump server for home.


\subsection{Links}
\label{\detokenize{services:id2}}\begin{itemize}
\item {} 
\sphinxurl{https://linux-audit.com/audit-and-harden-your-ssh-configuration/}

\item {} 
\sphinxurl{https://linux-audit.com/using-ssh-keys-instead-of-passwords/})

\end{itemize}


\chapter{Users}
\label{\detokenize{users:users}}\label{\detokenize{users::doc}}
We have four users on the system, here we’ll name them \sphinxtitleref{user1} to \sphinxtitleref{user4}. We
already have user1 from setting up the operating system.  For NFS, we have to
make sure that the UID and GID are the same on chell and home.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user2}
\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user3}
\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user4}
\end{sphinxVerbatim}

This gives us:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{user1}   \PYG{l+m+mi}{1000}\PYG{p}{:}\PYG{l+m+mi}{1000}
\PYG{n}{user2}   \PYG{l+m+mi}{1001}\PYG{p}{:}\PYG{l+m+mi}{1001}
\PYG{n}{user3}   \PYG{l+m+mi}{1002}\PYG{p}{:}\PYG{l+m+mi}{1002}
\PYG{n}{user4}   \PYG{l+m+mi}{1003}\PYG{p}{:}\PYG{l+m+mi}{1003}
\end{sphinxVerbatim}

Add group home with GUID 1010 (used for pictures):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{groupadd} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{l+m+mi}{1010} \PYG{n}{home}

\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user1} \PYG{n}{home}
\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user2} \PYG{n}{home}
\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user3} \PYG{n}{home}
\PYG{n}{sudo} \PYG{n}{adduser} \PYG{n}{user4} \PYG{n}{home}
\end{sphinxVerbatim}

The cats do not need separate user accounts, they just use root when they feel
like it.


\chapter{Mail}
\label{\detokenize{mail:mail}}\label{\detokenize{mail::doc}}
We need a basic mail setup to send notifications from ZFS and other systems in
case of an error. We use Postfix.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{postfix}
\end{sphinxVerbatim}

During setup, configure for an “Internet Site”. We use \sphinxcode{\sphinxupquote{home.local}} as the
sending address and \sphinxcode{\sphinxupquote{smtp.gmail.com:587}} as the relay host. Go to
\sphinxurl{https://myaccount.google.com/apppasswords} to get a password for “chell mail” and
create the file \sphinxcode{\sphinxupquote{/etc/postfix/sasl/sasl\_passwd}} with the content:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{smtp}\PYG{o}{.}\PYG{n}{gmail}\PYG{o}{.}\PYG{n}{com}\PYG{p}{]}\PYG{p}{:}\PYG{l+m+mi}{587} \PYG{o}{\PYGZlt{}}\PYG{n}{USERNAME}\PYG{o}{\PYGZgt{}}\PYG{n+nd}{@gmail}\PYG{o}{.}\PYG{n}{com}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{PASSWORD}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

This needs to be added to a data bank:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{postmap} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{postfix}\PYG{o}{/}\PYG{n}{sasl}\PYG{o}{/}\PYG{n}{sasl\PYGZus{}passwd}
\end{sphinxVerbatim}

In \sphinxcode{\sphinxupquote{/etc/postfix/main.cf}}  set the line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{relayhost} \PYG{o}{=} \PYG{p}{[}\PYG{n}{smtp}\PYG{o}{.}\PYG{n}{gmail}\PYG{o}{.}\PYG{n}{com}\PYG{p}{]}\PYG{p}{:}\PYG{l+m+mi}{587}
\end{sphinxVerbatim}

Shorten the line with the banner to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
smtpd\PYGZus{}banner = \PYGZdl{}myhostname ESMTP
\end{sphinxVerbatim}

for security reasons. And add the bunch of lines

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Enable SASL authentication}
\PYG{n}{smtp\PYGZus{}sasl\PYGZus{}auth\PYGZus{}enable} \PYG{o}{=} \PYG{n}{yes}
\PYG{c+c1}{\PYGZsh{} Disallow methods that allow anonymous authentication}
\PYG{n}{smtp\PYGZus{}sasl\PYGZus{}security\PYGZus{}options} \PYG{o}{=} \PYG{n}{noanonymous}
\PYG{c+c1}{\PYGZsh{} Location of sasl\PYGZus{}passwd}
\PYG{n}{smtp\PYGZus{}sasl\PYGZus{}password\PYGZus{}maps} \PYG{o}{=} \PYG{n+nb}{hash}\PYG{p}{:}\PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{postfix}\PYG{o}{/}\PYG{n}{sasl}\PYG{o}{/}\PYG{n}{sasl\PYGZus{}passwd}
\PYG{c+c1}{\PYGZsh{} Enable STARTTLS encryption}
\PYG{n}{smtp\PYGZus{}tls\PYGZus{}security\PYGZus{}level} \PYG{o}{=} \PYG{n}{encrypt}
\PYG{c+c1}{\PYGZsh{} Location of CA certificates}
\PYG{n}{smtp\PYGZus{}tls\PYGZus{}CAfile} \PYG{o}{=} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{ssl}\PYG{o}{/}\PYG{n}{certs}\PYG{o}{/}\PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n}{certificates}\PYG{o}{.}\PYG{n}{crt}
\end{sphinxVerbatim}

Edit aliases file with \sphinxcode{\sphinxupquote{sudo vi /etc/aliases}} so it reads:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{postmaster}\PYG{p}{:} \PYG{n}{root}
\PYG{n}{admin}\PYG{p}{:} \PYG{n}{root}
\PYG{n}{ubuntu}\PYG{p}{:} \PYG{n}{root}
\PYG{n}{root}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{USERNAME}\PYG{o}{\PYGZgt{}}\PYG{n+nd}{@gmail}\PYG{o}{.}\PYG{n}{com}
\end{sphinxVerbatim}

The run sudo newaliases for the databank file and sudo systemctl restart postfix. Test with a mail that ends with a dot:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sendmail} \PYG{o}{\PYGZlt{}}\PYG{n}{USERNAME}\PYG{o}{\PYGZgt{}}\PYG{n+nd}{@gmail}\PYG{o}{.}\PYG{n}{com}
\PYG{n}{From}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{USERNAME}\PYG{o}{\PYGZgt{}}\PYG{o}{@}\PYG{o}{\PYGZlt{}}\PYG{n}{OTHER\PYGZus{}ADDRESS}\PYG{o}{\PYGZgt{}}
\PYG{n}{Subject}\PYG{p}{:} \PYG{n}{Test} \PYG{n}{mail}
\PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{test} \PYG{n}{email}
\end{sphinxVerbatim}

This is basic mail setup. We need the mailutils package for further use.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{mailutils}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
This setup will now allow us to send all kinds of mail with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mail} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}SUBJECT\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{the}\PYG{o}{.}\PYG{n}{address}\PYG{n+nd}{@the}\PYG{o}{.}\PYG{n}{address}
\PYG{o}{\PYGZlt{}}\PYG{n}{MORE} \PYG{n}{TEXT}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{CTRL}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{n}{d}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Links}
\label{\detokenize{mail:links}}\begin{itemize}
\item {} 
\sphinxurl{https://www.linode.com/docs/email/postfix/configure-postfix-to-send-mail-using-gmail-and-google-apps-on-debian-or-ubuntu/}

\end{itemize}


\chapter{SMART}
\label{\detokenize{smart:smart}}\label{\detokenize{smart::doc}}
Installing the SMART disk drive monitoring system. This assumes email
notifications are set up correctly.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{smartmontools}
\end{sphinxVerbatim}

Edit \sphinxcode{\sphinxupquote{/etc/default/smartmontools}} so that \sphinxcode{\sphinxupquote{start\_smartd=yes}}. Now edit
\sphinxcode{\sphinxupquote{/etc/smartd.conf}} with a first test setup of

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DEVICESCAN} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{o}{\PYGZlt{}}\PYG{n}{USERNAME}\PYG{o}{\PYGZgt{}}\PYG{n+nd}{@gmail}\PYG{o}{.}\PYG{n}{com} \PYG{o}{\PYGZhy{}}\PYG{n}{M} \PYG{n}{test}
\end{sphinxVerbatim}

Then restart the service with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{service} \PYG{n}{smartd} \PYG{n}{restart}
\end{sphinxVerbatim}

Should send an email for every drive. Then edit the line to show

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DEVICESCAN} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{p}{(}\PYG{n}{S}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{19}\PYG{o}{\textbar{}}\PYG{n}{L}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{l+m+mi}{02}\PYG{o}{/}\PYG{o}{.}\PYG{o}{/}\PYG{l+m+mi}{21}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{n}{m} \PYG{o}{\PYGZlt{}}\PYG{n}{USERNAME}\PYG{o}{\PYGZgt{}}\PYG{n+nd}{@gmail}\PYG{o}{.}\PYG{n}{com}
\end{sphinxVerbatim}

Where \sphinxcode{\sphinxupquote{-a}} is \sphinxcode{\sphinxupquote{-H -f -t -l error -l selftest -C 197 -U 198}}. This does a
short test every Monday at 19:00h and a long test every second day of the month
at 21:00h - make sure there isn’t a ZFS scrub at the same time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{service} \PYG{n}{smartd} \PYG{n}{restart}
\end{sphinxVerbatim}

And restart the service again.

\begin{sphinxadmonition}{note}{Note:}
NVMe SMART support is rudimentary, see \sphinxurl{https://www.smartmontools.org/wiki/NVMe\_Support}.
\end{sphinxadmonition}


\section{Links}
\label{\detokenize{smart:links}}\begin{itemize}
\item {} 
\sphinxurl{https://help.ubuntu.com/community/Smartmontools}

\item {} 
\sphinxurl{https://wiki.archlinux.org/index.php/S.M.A.R.T}.

\item {} 
\sphinxurl{https://www.smartmontools.org/browser/trunk/smartmontools/smartd.conf.5.in}

\end{itemize}


\chapter{UPS}
\label{\detokenize{ups:ups}}\label{\detokenize{ups::doc}}
This is with the UPS APC 700VA BX700U-GR

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{apcupsd}
\PYG{n}{sudo} \PYG{n}{cp} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{conf} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{conf}\PYG{o}{.}\PYG{n}{bak}
\PYG{n}{sudo} \PYG{n}{vi} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{conf}
\end{sphinxVerbatim}

Notes some of these are just the defaults.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ANNOY} \PYG{l+m+mi}{300}
\PYG{n}{ANNOYDELAY} \PYG{l+m+mi}{60}
\PYG{n}{BATTERYLEVEL} \PYG{l+m+mi}{20}
\PYG{n}{DATATIME} \PYG{l+m+mi}{0}
\PYG{n}{DEVICE}
\PYG{n}{EVENTSFILE} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{log}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{events}
\PYG{n}{EVENTSFILEMAX} \PYG{l+m+mi}{10}
\PYG{n}{KILLDELAY} \PYG{l+m+mi}{0}
\PYG{n}{LOCKFILE} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lock}
\PYG{n}{LOGSTATS} \PYG{n}{off}
\PYG{n}{MINUTES} \PYG{l+m+mi}{10}
\PYG{n}{NETSERVER} \PYG{n}{on}
\PYG{n}{NISIP} \PYG{l+m+mf}{127.0}\PYG{o}{.}\PYG{l+m+mf}{0.1}
\PYG{n}{NISPORT} \PYG{l+m+mi}{3551}
\PYG{n}{NOLOGINDIR} \PYG{o}{/}\PYG{n}{etc}
\PYG{n}{NOLOGON} \PYG{n}{disable}
\PYG{n}{ONBATTERYDELAY} \PYG{l+m+mi}{6}
\PYG{n}{POLLTIME} \PYG{l+m+mi}{90}
\PYG{n}{PWRFAILDIR} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apcupsd}
\PYG{n}{SCRIPTDIR} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apcupsd}
\PYG{n}{STATFILE} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{log}\PYG{o}{/}\PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{status}
\PYG{n}{STATTIME} \PYG{l+m+mi}{0}
\PYG{n}{TIMEOUT} \PYG{l+m+mi}{0}
\PYG{n}{UPSCABLE} \PYG{n}{usb}
\PYG{n}{UPSCLASS} \PYG{n}{standalone}
\PYG{n}{UPSMODE} \PYG{n}{disable}
\PYG{n}{UPSNAME} \PYG{n}{BX700U}
\PYG{n}{UPSTYPE} \PYG{n}{usb}
\end{sphinxVerbatim}

We also have to edit

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{vi} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{default}\PYG{o}{/}\PYG{n}{apcupsd}
\end{sphinxVerbatim}

and there set \sphinxcode{\sphinxupquote{ISCONFIGURED=yes}}. Restart the service after configuration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{systemctl} \PYG{n}{restart} \PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{service}
\PYG{n}{sudo} \PYG{n}{systemctl} \PYG{n}{status} \PYG{n}{apcupsd}\PYG{o}{.}\PYG{n}{service}
\end{sphinxVerbatim}

The command sudo apcaccess gives a dump of features. Then to test the settings, stop the demon and run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apctest}
\end{sphinxVerbatim}

We still have to test it by pulling the plug.


\section{Links}
\label{\detokenize{ups:links}}\begin{itemize}
\item {} 
\sphinxurl{http://www.apcupsd.org/manual/manual.html}

\item {} 
\sphinxurl{https://www.pontikis.net/blog/apc-ups-on-ubuntu-workstation})

\end{itemize}


\chapter{ZFS}
\label{\detokenize{zfs:zfs}}\label{\detokenize{zfs::doc}}
As described earlier, we use ZFS because it is one of the few file systems that
can detect and correct bitrot. At time of writing, Ubuntu is the only major
Linux variant to support ZFS out of the box.


\section{The current setup}
\label{\detokenize{zfs:the-current-setup}}
\begin{sphinxadmonition}{note}{Note:}
We inherited our data storage pool “tank” from the previous FreeNAS
install, so there is currently no discussion of how to setup and
configure a ZFS pool and datasets.
\end{sphinxadmonition}

We import the pool with \sphinxcode{\sphinxupquote{zpool import -f tank}}. Since this computer will be
used as a NAS, we don’t limit the size of the ARC, which defaults to half the
RAM.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{install} \PYG{n}{zfsutils}
\end{sphinxVerbatim}

We currently have the following file systems (“datasets”) for bulk storage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{coldstore}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{media}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{pictures}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{storage}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{texts}
\end{sphinxVerbatim}

Also, each of the users has a separate dataset for backups:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user1}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user2}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user3}
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user4}
\end{sphinxVerbatim}

Finally, there is a file system for the Time Machine backups:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tank}\PYG{o}{/}\PYG{n}{TM\PYGZus{}mediator}
\end{sphinxVerbatim}


\section{Email notifications}
\label{\detokenize{zfs:email-notifications}}
This assumes we have basic mail notifications working with postfix.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{vi} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{zfs}\PYG{o}{/}\PYG{n}{zed}\PYG{o}{.}\PYG{n}{d}\PYG{o}{/}\PYG{n}{zed}\PYG{o}{.}\PYG{n}{rc}
\end{sphinxVerbatim}

so that we have (note these are commented out by default):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ZED\PYGZus{}EMAIL\PYGZus{}ADDR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}USER1}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{S MAIL ADDRESS\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{ZED\PYGZus{}EMAIL\PYGZus{}PROG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mail}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{ZED\PYGZus{}EMAIL\PYGZus{}OPTS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}s }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{@SUBJECT@}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ @ADDRESS@}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{ZED\PYGZus{}NOTIFY\PYGZus{}VERBOSE}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{ZED\PYGZus{}NOTIFY\PYGZus{}DATA}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

Follow this with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{systemctl} \PYG{n}{restart} \PYG{n}{zed}
\end{sphinxVerbatim}

Test with scrub of tank, should send mail.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{zpool} \PYG{n}{scrub} \PYG{n}{tank}
\end{sphinxVerbatim}

We will setup snapshots in a later step.


\subsection{Links}
\label{\detokenize{zfs:links}}\begin{itemize}
\item {} 
\sphinxurl{https://github.com/zfsonlinux/zfs/issues/6246}

\end{itemize}


\chapter{Containers}
\label{\detokenize{containers:containers}}\label{\detokenize{containers::doc}}
\begin{sphinxadmonition}{note}{Note:}
We currently use Docker, though Podman might make more sense for a
system this size because it doesn’t need a separate demon and doesn’t
run with root. However, Ubuntu currently has better support for Docker
than Podman.
\end{sphinxadmonition}

You will remember we didn’t install Docker during the setups of the operating
system because that would have given us the wrong version.

\begin{sphinxadmonition}{note}{Note:}
This is the easy way to install, though it doesn’t give you the newest
version (a common problem with Ubuntu). See
\sphinxurl{https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04}
for instructions on how to install the program from the official Docker
repository.
\end{sphinxadmonition}

The basic install of Docker is with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{docker}\PYG{o}{.}\PYG{n}{io}
\PYG{n}{sudo} \PYG{n}{systemctl} \PYG{n}{enable} \PYG{n}{docker}
\end{sphinxVerbatim}

The second line is responsible for autostarting. What follows are the
individual container installations. We also install a container for Time Machine
backups, but we’ll get to that later.


\section{Glances}
\label{\detokenize{containers:glances}}
Glances provides an overview of the system. Though there are monitors that
provide more information, this seems to be a good balance of size and function
for a NAS with our profile.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{pull} \PYG{n}{nicolargo}\PYG{o}{/}\PYG{n}{glances}
\end{sphinxVerbatim}

Create a folder \sphinxcode{\sphinxupquote{/root/Docker-scripts}}. There, create a file \sphinxcode{\sphinxupquote{glances-docker.sh}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{glances}\PYG{o}{\PYGZhy{}}\PYG{n}{home} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{restart} \PYG{n}{unless}\PYG{o}{\PYGZhy{}}\PYG{n}{stopped} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{publish} \PYG{l+m+mi}{61208}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{61209}\PYG{p}{:}\PYG{l+m+mi}{61208}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{61209}  \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{env} \PYG{n}{GLANCES\PYGZus{}OPT}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}w}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{volume} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{run}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{run}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}\PYG{n}{ro} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{pid} \PYG{n}{host} \PYGZbs{}
\PYG{n}{docker}\PYG{o}{.}\PYG{n}{io}\PYG{o}{/}\PYG{n}{nicolargo}\PYG{o}{/}\PYG{n}{glances}
\end{sphinxVerbatim}

We start with is \sphinxcode{\sphinxupquote{sudo ./glances-docker.sh}}. To reach the interface, go to
\sphinxurl{http://home.local:61208} .

\begin{sphinxadmonition}{note}{Note:}
This might need some tweaking, because Glances is unhappy when 70 percent
of memory is used, which is normal for a NAS.
\end{sphinxadmonition}


\section{Emby}
\label{\detokenize{containers:emby}}
Emby is one of three options for TV and movie streaming, the other two are Plex
and JellyFin. We create a volume for configuration files, so we don’t have to
reorganize every time there is a new version.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{pull} \PYG{n}{emby}\PYG{o}{/}\PYG{n}{embyserver}\PYG{p}{:}\PYG{n}{latest}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{volume} \PYG{n}{create} \PYG{n}{emby}\PYG{o}{\PYGZhy{}}\PYG{n}{config}
\end{sphinxVerbatim}

Create a file in \sphinxcode{\sphinxupquote{/root/Docker-scripts/}} named \sphinxcode{\sphinxupquote{emby-docker.sh}} with the
content:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{emby}\PYG{o}{\PYGZhy{}}\PYG{n}{home} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{volume} \PYG{n}{emby}\PYG{o}{\PYGZhy{}}\PYG{n}{config}\PYG{p}{:}\PYG{o}{/}\PYG{n}{config} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{volume} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{media}\PYG{o}{/}\PYG{n}{movies}\PYG{p}{:}\PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{movies}\PYG{p}{:}\PYG{n}{ro} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{volume} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{media}\PYG{o}{/}\PYG{n}{series}\PYG{p}{:}\PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{tv}\PYG{p}{:}\PYG{n}{ro} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{publish} \PYG{l+m+mi}{8096}\PYG{p}{:}\PYG{l+m+mi}{8096} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{publish} \PYG{l+m+mi}{8920}\PYG{p}{:}\PYG{l+m+mi}{8920} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{restart} \PYG{n}{unless}\PYG{o}{\PYGZhy{}}\PYG{n}{stopped} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{env} \PYG{n}{UID}\PYG{o}{=}\PYG{l+m+mi}{1000} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{env} \PYG{n}{GID}\PYG{o}{=}\PYG{l+m+mi}{1000} \PYGZbs{}
\PYG{n}{emby}\PYG{o}{/}\PYG{n}{embyserver}\PYG{p}{:}\PYG{n}{latest}
\end{sphinxVerbatim}

The actual media files are kept in the ZFS datasets \sphinxcode{\sphinxupquote{tank/media}}, and we pass
them \sphinxcode{\sphinxupquote{ro}} (read-only) to be paranoid. Run it and setup at
\sphinxurl{http://home.local:8096} . During setup, set thread count to 4 for the moment.


\subsection{Configuration backups}
\label{\detokenize{containers:configuration-backups}}
We keep a backup of the \sphinxcode{\sphinxupquote{emby-config}} volume from
\sphinxcode{\sphinxupquote{/var/lib/docker/volumes/emby-config}} at \sphinxcode{\sphinxupquote{/tank/storage/BKU Emby/}}. The
uncompressed size (02. June 2019) is about 3 GB.


\section{Watchtower}
\label{\detokenize{containers:watchtower}}
Watchtower is a program to automatically update other containers. This seems a
bit overkill for our small collection, but we might as well set it up.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{pull} \PYG{n}{v2tec}\PYG{o}{/}\PYG{n}{watchtower}
\end{sphinxVerbatim}

Create \sphinxcode{\sphinxupquote{watchtower-docker.sh}} file in the usual folder, configured to run once
a night:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{watchtower}\PYG{o}{\PYGZhy{}}\PYG{n}{home} \PYGZbs{}
\PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{run}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{run}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{sock} \PYGZbs{}
\PYG{n}{v2tec}\PYG{o}{/}\PYG{n}{watchtower} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{schedule} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 0 5 * * *}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{cleanup}
\end{sphinxVerbatim}

This runs the check once a day at five in the morning and gets rid of old stuff
once it has updated.


\section{Time Machine}
\label{\detokenize{containers:time-machine}}
We do this with Docker because Ubuntu (again) uses an ancient version of
netatalk.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{dit} \PYGZbs{}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{timemachine}\PYG{o}{\PYGZhy{}}\PYG{n}{home}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{restart}\PYG{o}{=}\PYG{n}{unless}\PYG{o}{\PYGZhy{}}\PYG{n}{stopped}
  \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{TM\PYGZus{}mediator}\PYG{p}{:}\PYG{o}{/}\PYG{n}{timemachine}
  \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mi}{548}\PYG{p}{:}\PYG{l+m+mi}{548}
  \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mi}{636}\PYG{p}{:}\PYG{l+m+mi}{636}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{ulimit} \PYG{n}{nofile}\PYG{o}{=}\PYG{l+m+mi}{65536}\PYG{p}{:}\PYG{l+m+mi}{65536}
\PYG{n}{odarriba}\PYG{o}{/}\PYG{n}{timemachine}
\end{sphinxVerbatim}

We have to run another line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{exec} \PYG{n}{timemachine}\PYG{o}{\PYGZhy{}}\PYG{n}{home} \PYG{n}{add}\PYG{o}{\PYGZhy{}}\PYG{n}{account} \PYG{n}{user1} \PYG{o}{\PYGZlt{}}\PYG{n}{PASSWORD}\PYG{o}{\PYGZgt{}} \PYG{n}{Hive}\PYG{o}{\PYGZhy{}}\PYG{n}{TM} \PYG{o}{/}\PYG{n}{timemachine}
\end{sphinxVerbatim}

On the Mac, use COMMAND-K to input \sphinxcode{\sphinxupquote{afp://192.168.13.2/Hive-TM}} which is the name of
the share. This could probably be home.local as well. Mount the drive that way
by hand and then configure it as a new Time Machine backup drive.


\section{Links}
\label{\detokenize{containers:links}}\begin{itemize}
\item {} 
\sphinxurl{https://hub.docker.com/r/v2tec/watchtower/}

\item {} 
\sphinxurl{https://godoc.org/github.com/robfig/cron\#hdr-CRON\_Expression\_Format}

\item {} 
\sphinxurl{https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04}

\item {} 
\sphinxurl{https://github.com/nicolargo/glances}

\item {} 
\sphinxurl{https://glances.readthedocs.io/en/stable/docker.html}

\item {} 
\sphinxurl{https://glances.readthedocs.io/en/stable/cmds.html\#interactive-commands}

\item {} 
\sphinxurl{https://hub.docker.com/r/odarriba/timemachine/}

\item {} 
\sphinxurl{https://github.com/odarriba/docker-timemachine}

\end{itemize}


\chapter{NFS}
\label{\detokenize{nfs:nfs}}\label{\detokenize{nfs::doc}}
Only operating systems from the Unix family - Linux, MacOS - will be accessing
this NAS and the environment is relatively secure, so we can use NFS instead of
Samba for better performance.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{nfs}\PYG{o}{\PYGZhy{}}\PYG{n}{kernel}\PYG{o}{\PYGZhy{}}\PYG{n}{server}
\end{sphinxVerbatim}

We link the various datasets through a folder so we don’t have to export the
actual datasets. This is experimental.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{o}{/}\PYG{n}{exports}

\PYG{n}{ln} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{pictures}\PYG{o}{/} \PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{pictures}
\PYG{n}{ln} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{coldstore}\PYG{o}{/} \PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{coldstore}
\PYG{n}{ln} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{media}\PYG{o}{/} \PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{media}
\PYG{n}{ln} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{storage}\PYG{o}{/} \PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{storage}
\PYG{n}{ln} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{texts}\PYG{o}{/} \PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{texts}
\end{sphinxVerbatim}

In \sphinxcode{\sphinxupquote{/etc/exports}}, add the following lines:

\begin{sphinxadmonition}{note}{Note:}
We leave the addresses as 192.168.0.0 instead of 192.168.13.0 as
might be expected because we’ll be putting the high-speed SFP+
network on a different subnet at some point.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{exports} \PYG{o}{*}\PYG{p}{(}\PYG{n}{ro}\PYG{p}{,}\PYG{n}{fsid}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{no\PYGZus{}subtree\PYGZus{}check}\PYG{p}{)}
\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{pictures} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{(}\PYG{n}{rw}\PYG{p}{,}\PYG{n}{no\PYGZus{}subtree\PYGZus{}check}\PYG{p}{)}
\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{coldstore} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{(}\PYG{n}{rw}\PYG{p}{,}\PYG{n}{no\PYGZus{}subtree\PYGZus{}check}\PYG{p}{)}
\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{media} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{(}\PYG{n}{rw}\PYG{p}{,}\PYG{n}{no\PYGZus{}subtree\PYGZus{}check}\PYG{p}{)}
\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{storage} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{(}\PYG{n}{rw}\PYG{p}{,}\PYG{n}{no\PYGZus{}subtree\PYGZus{}check}\PYG{p}{)}
\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{texts} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{(}\PYG{n}{rw}\PYG{p}{,}\PYG{n}{no\PYGZus{}subtree\PYGZus{}check}\PYG{p}{)}
\end{sphinxVerbatim}

On the target machine, we need the setup in \sphinxcode{\sphinxupquote{/etc/fstab}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{home}\PYG{o}{.}\PYG{n}{local}\PYG{p}{:}\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{coldstore} \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{coldstore}  \PYG{n}{nfs} \PYG{n}{noatime}\PYG{p}{,}\PYG{n}{noauto} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\PYG{n}{home}\PYG{o}{.}\PYG{n}{local}\PYG{p}{:}\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{storage}   \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{storage}    \PYG{n}{nfs} \PYG{n}{noatime}\PYG{p}{,}\PYG{n}{auto} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\PYG{n}{home}\PYG{o}{.}\PYG{n}{local}\PYG{p}{:}\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{media}     \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{media}      \PYG{n}{nfs} \PYG{n}{noatime}\PYG{p}{,}\PYG{n}{auto} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\PYG{n}{home}\PYG{o}{.}\PYG{n}{local}\PYG{p}{:}\PYG{o}{/}\PYG{n}{exports}\PYG{o}{/}\PYG{n}{pictures}  \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{pictures}   \PYG{n}{nfs} \PYG{n}{noatime}\PYG{p}{,}\PYG{n}{auto} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

Then run \sphinxcode{\sphinxupquote{sudo exportfs -a}} to make sure we know about this. Finally, just to be sure, try

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{systemctl} \PYG{n}{restart} \PYG{n}{nfs}\PYG{o}{\PYGZhy{}}\PYG{n}{kernel}\PYG{o}{\PYGZhy{}}\PYG{n}{server}
\end{sphinxVerbatim}


\section{Links}
\label{\detokenize{nfs:links}}\begin{itemize}
\item {} 
\sphinxurl{https://unix.stackexchange.com/questions/106122/mount-nfs-access-denied-by-server-while-mounting-on-ubuntu-machines}

\end{itemize}


\chapter{Snapshots}
\label{\detokenize{snapshots:snapshots}}\label{\detokenize{snapshots::doc}}
We use Sanoid \sphinxurl{https://github.com/jimsalterjrs/sanoid} to automatically create and
prune ZFS snapshots. Note this is a backup server, so we don’t need hourly
snapshots for the users because we’re only fed their stuff once a day anyway.

Sanoid is not part of the Ubuntu distribution, so we need to set it up from the
GitHub repository.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{libconfig}\PYG{o}{\PYGZhy{}}\PYG{n}{inifiles}\PYG{o}{\PYGZhy{}}\PYG{n}{perl}
\PYG{n}{cd} \PYG{o}{/}\PYG{n}{opt}
\PYG{n}{sudo} \PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{jimsalterjrs}\PYG{o}{/}\PYG{n}{sanoid}
\PYG{n}{sudo} \PYG{n}{ln} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{/}\PYG{n}{sanoid} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{sbin}\PYG{o}{/}
\PYG{n}{sudo} \PYG{n}{mkdir} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{sanoid}
\PYG{n}{sudo} \PYG{n}{cp} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{.}\PYG{n}{conf} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{.}\PYG{n}{conf}
\PYG{n}{sudo} \PYG{n}{cp} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{.}\PYG{n}{defaults}\PYG{o}{.}\PYG{n}{conf} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{/}\PYG{n}{sanoid}\PYG{o}{.}\PYG{n}{defaults}\PYG{o}{.}\PYG{n}{conf}
\end{sphinxVerbatim}

In \sphinxcode{\sphinxupquote{/etc/sanoid.conf}} we have the templates and the datasets they refer to.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{coldstore}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{archive}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user3}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{slacker}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user2}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{backup}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user1}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{busybee}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user4}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{slacker}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{media}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{archive}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{pictures}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{archive}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{storage}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{archive}

\PYG{p}{[}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{texts}\PYG{p}{]}
        \PYG{n}{use\PYGZus{}template} \PYG{o}{=} \PYG{n}{archive}


\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} TEMPLATES \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{c+c1}{\PYGZsh{} User who only occasionally logs in. We want to be able to catch when they}
\PYG{c+c1}{\PYGZsh{} come the next day and says \PYGZdq{}dude, I lost my file\PYGZdq{}}
\PYG{p}{[}\PYG{n}{template\PYGZus{}slacker}\PYG{p}{]}
        \PYG{n}{frequently} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{hourly} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{daily} \PYG{o}{=} \PYG{l+m+mi}{7}
        \PYG{n}{weekly} \PYG{o}{=} \PYG{l+m+mi}{4}
        \PYG{n}{monthly} \PYG{o}{=} \PYG{l+m+mi}{4}
        \PYG{n}{yearly} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{autosnap} \PYG{o}{=} \PYG{n}{yes}
        \PYG{n}{autoprune} \PYG{o}{=} \PYG{n}{yes}

\PYG{c+c1}{\PYGZsh{} User who does a lot of work and could lose a lot}
\PYG{p}{[}\PYG{n}{template\PYGZus{}busybee}\PYG{p}{]}
        \PYG{n}{frequently} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{hourly} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{daily} \PYG{o}{=} \PYG{l+m+mi}{31}
        \PYG{n}{weekly} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{monthly} \PYG{o}{=} \PYG{l+m+mi}{12}
        \PYG{n}{yearly} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{autosnap} \PYG{o}{=} \PYG{n}{yes}
        \PYG{n}{autoprune} \PYG{o}{=} \PYG{n}{yes}

\PYG{c+c1}{\PYGZsh{} Backup for people whose data comes from outside and is transferred by rsync.}
\PYG{p}{[}\PYG{n}{template\PYGZus{}backup}\PYG{p}{]}
        \PYG{n}{frequently} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{hourly} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{daily} \PYG{o}{=} \PYG{l+m+mi}{7}
        \PYG{n}{weekly} \PYG{o}{=} \PYG{l+m+mi}{4}
        \PYG{n}{monthly} \PYG{o}{=} \PYG{l+m+mi}{12}
        \PYG{n}{yearly} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{autosnap} \PYG{o}{=} \PYG{n}{yes}
        \PYG{n}{autoprune} \PYG{o}{=} \PYG{n}{yes}

\PYG{c+c1}{\PYGZsh{} Backup for media files and other archived data. We usually don\PYGZsq{}t}
\PYG{c+c1}{\PYGZsh{} delete anything in these datasets, but only add stuff, so we want}
\PYG{c+c1}{\PYGZsh{} to avoid cryptolocker attacks and catch \PYGZdq{}oops\PYGZdq{} accidents.}
\PYG{p}{[}\PYG{n}{template\PYGZus{}archive}\PYG{p}{]}
        \PYG{n}{frequently} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{hourly} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{daily} \PYG{o}{=} \PYG{l+m+mi}{3}
        \PYG{n}{weekly} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{monthly} \PYG{o}{=} \PYG{l+m+mi}{3}
        \PYG{n}{yearly} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{autosnap} \PYG{o}{=} \PYG{n}{yes}
        \PYG{n}{autoprune} \PYG{o}{=} \PYG{n}{yes}
\end{sphinxVerbatim}

Edit \sphinxcode{\sphinxupquote{/etc/crontab}} by hand (we don’t care about skipping one hour during
daylight savings transition):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{o}{/}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{n}{root} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{sbin}\PYG{o}{/}\PYG{n}{sanoid} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{cron}
\end{sphinxVerbatim}

After about five minutes, you’ll see snapshots appearing when you run \sphinxcode{\sphinxupquote{zfs list
-t snapshot}}.

\begin{sphinxadmonition}{note}{Note:}
The datasets used for Time Backups are not snapshotted.
\end{sphinxadmonition}


\section{Deleting snapshots}
\label{\detokenize{snapshots:deleting-snapshots}}
Use the \sphinxcode{\sphinxupquote{-n}} switch to test what we do before we do it. Format is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{zfs} \PYG{n}{destroy} \PYG{o}{\PYGZhy{}}\PYG{n}{vn} \PYG{o}{\PYGZlt{}}\PYG{n}{FIRST}\PYG{o}{\PYGZhy{}}\PYG{n}{SNAPSHOT}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZpc{}}\PYG{o}{\PYGZlt{}}\PYG{n}{LAST}\PYG{o}{\PYGZhy{}}\PYG{n}{SNAPSHOT}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Where last snapshot is only the part after the \sphinxcode{\sphinxupquote{@}}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{zfs} \PYG{n}{destroy} \PYG{o}{\PYGZhy{}}\PYG{n}{vn} \PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user1}\PYG{n+nd}{@auto}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20190303.0900}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{n}{m}\PYG{o}{\PYGZpc{}}\PYG{n}{auto}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20190601.0900}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{n}{m}
\end{sphinxVerbatim}

This will also tell you how much space will be freed. Do this with without
\sphinxcode{\sphinxupquote{-vn}} to pull the trigger.


\chapter{Rsync}
\label{\detokenize{rsync:rsync}}\label{\detokenize{rsync::doc}}
We use rsync for backups from the Linux computers to the NAS.

\begin{sphinxadmonition}{note}{Note:}
This is a rather crude way of doing things, left over from earlier
setups. In future versions, this will probably be replaced by \sphinxcode{\sphinxupquote{zfs
send/receive}} or Syncoid (\sphinxurl{https://github.com/jimsalterjrs/sanoid})
\end{sphinxadmonition}

In the user file \sphinxcode{\sphinxupquote{/home/user1/rsync\_home.sh}} we put:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{n}{rsync} \PYG{o}{\PYGZhy{}}\PYG{n}{az} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ssh \PYGZhy{}p 2019}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{delete} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{exclude}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{n}{cache}\PYG{p}{,}\PYG{o}{.}\PYG{n}{steam}\PYG{p}{,}\PYG{o}{.}\PYG{n}{zfs}\PYG{p}{,}\PYG{o}{.}\PYG{n}{dbus}\PYG{p}{,}\PYG{n}{go}\PYG{p}{,}\PYG{n}{snap}\PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{user1}\PYG{o}{/} \PYG{n}{user1}\PYG{n+nd}{@home}\PYG{o}{.}\PYG{n}{local}\PYG{p}{:}\PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user1}\PYG{o}{/}\PYG{n}{bku\PYGZus{}chell}
\end{sphinxVerbatim}

We can test this with the rsync \sphinxcode{\sphinxupquote{vn}} flags to be certain. Then, add crontab
job with \sphinxcode{\sphinxupquote{crontab -e}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{05} \PYG{l+m+mi}{17}  \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{user1}\PYG{o}{/}\PYG{n}{rsync\PYGZus{}home}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

For the other users, we need to generate ssh keys, such as user2. Then, on home as that user:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{o}{.}\PYG{n}{ssh}
\PYG{n}{vi} \PYG{o}{.}\PYG{n}{ssh}\PYG{o}{/}\PYG{n}{authorized\PYGZus{}keys}
\end{sphinxVerbatim}

Copy the public key \sphinxcode{\sphinxupquote{id\_rsa.pub}} content to that file. To test, run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssh} \PYG{n}{home}\PYG{o}{.}\PYG{n}{local} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mi}{2019}
\end{sphinxVerbatim}

once from user2’s account. Then, test as above (with nv) options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rsync} \PYG{o}{\PYGZhy{}}\PYG{n}{az} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ssh \PYGZhy{}p 2019}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{delete} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{exclude}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{n}{cache}\PYG{p}{,}\PYG{o}{.}\PYG{n}{steam}\PYG{p}{,}\PYG{o}{.}\PYG{n}{zfs}\PYG{p}{,}\PYG{o}{.}\PYG{n}{dbus}\PYG{p}{,}\PYG{n}{snap}\PYG{p}{\PYGZcb{}} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{user2}\PYG{o}{/} \PYG{n}{user2}\PYG{n+nd}{@home}\PYG{o}{.}\PYG{n}{local}\PYG{p}{:}\PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user2}\PYG{o}{/}\PYG{n}{bku\PYGZus{}chell}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
This line is the reason we do not issue a banner with sshd.
\end{sphinxadmonition}

If that works, put it into a shell script like for user1 with a slightly different time:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{25} \PYG{l+m+mi}{17} \PYG{o}{*} \PYG{o}{*} \PYG{o}{*} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{user2}\PYG{o}{/}\PYG{n}{rsync\PYGZus{}home}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

Repeat the process with other users.


\section{Links}
\label{\detokenize{rsync:links}}\begin{itemize}
\item {} 
\sphinxurl{https://www.linode.com/docs/security/authentication/use-public-key-authentication-with-ssh/}

\item {} 
\sphinxurl{https://jrs-s.net/2016/09/15/zfs-snapshots-and-cold-storage/}

\item {} 
\sphinxurl{https://blog.fosketts.net/2016/08/18/migrating-data-zfs-send-receive/}

\end{itemize}


\chapter{Firewall}
\label{\detokenize{firewall:firewall}}\label{\detokenize{firewall::doc}}
We have the advantage that there is an actual terminal hooked up to the server,
so we can just walk over and configure stuff by hand if it doesn’t work. In
other words, we can be very restrictive. The goals:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Everybody can access \sphinxstylestrong{Emby}

\item {} 
The Apple computers can access \sphinxstylestrong{Time Machine}

\item {} 
Everybody on the local net can access \sphinxstylestrong{Glances}

\item {} 
Core is the jump server for home, so chell can \sphinxstylestrong{ssh}; worker needs to ssh into home for backups

\item {} 
We need to allow access to Avahi (\sphinxstylestrong{mDNS}) to all in the local network

\item {} 
Allow \sphinxstylestrong{NFS} access from chell

\end{enumerate}

Out of the box, we get an “inactive” with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{status}
\end{sphinxVerbatim}

Which is good. First we start with the basics:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{default} \PYG{n}{deny} \PYG{n}{incoming}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{default} \PYG{n}{allow} \PYG{n}{outgoing}
\end{sphinxVerbatim}

Then we explicitly reject ssh via the normal port 22 (don’t leave the user
hanging, because this will be a simple mistake that will be made often):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{reject} \PYG{n}{ssh}
\end{sphinxVerbatim}

For the other goals:
\begin{description}
\item[{\sphinxstylestrong{Goal 1:} Emby}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{8096} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Emby HTTP}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item[{\sphinxstylestrong{Goal 2:} Time Machine access from mediator}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.22} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{548} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TM from mediator}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.22} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{427} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TM from mediator}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item[{\sphinxstylestrong{Goal 3:} Glances from local network}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.0}\PYG{o}{/}\PYG{l+m+mi}{24} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{61208} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Glances}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item[{\sphinxstylestrong{Goal 4:} Allow ssh from chell and worker}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{n}{proto} \PYG{n}{tcp} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{2019} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ssh from chell}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{n}{proto} \PYG{n}{tcp} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.21} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{2019} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ssh from worker}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item[{\sphinxstylestrong{Goal 5:} Allow mDNS}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{n}{mdns} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mDNS}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item[{\sphinxstylestrong{Goal 6:} Allow NFS access from chell}] \leavevmode
This is more tricky, because the mountd changes the port by default.

Edit \sphinxcode{\sphinxupquote{/etc/default/nfs-kernel-server}} and change the line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RPCMOUNTDOPTS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}manage\PYGZhy{}gids}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

and make it into

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RPCMOUNTDOPTS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}port 33333}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

This is just a number that was easy to remember. Now restart the server.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{service} \PYG{n}{nfs}\PYG{o}{\PYGZhy{}}\PYG{n}{kernel}\PYG{o}{\PYGZhy{}}\PYG{n}{server} \PYG{n}{restart}
\end{sphinxVerbatim}

Add the correct firewall rules:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{n}{nfs} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NFS from chell}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{111} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NFS from chell}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{k+kn}{from} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{port} \PYG{l+m+mi}{33333} \PYG{n}{comment} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NFS from chell}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

Disable and re-enable the firewall.

\end{description}

Status verbose gives us:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{To}           \PYG{n}{Action}      \PYG{n}{From}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}           \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}      \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m+mi}{5353}         \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{n}{Anywhere}          \PYG{c+c1}{\PYGZsh{} mDNS}
\PYG{l+m+mi}{2019}\PYG{o}{/}\PYG{n}{tcp}     \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20}     \PYG{c+c1}{\PYGZsh{} ssh from chell}
\PYG{l+m+mi}{2019}\PYG{o}{/}\PYG{n}{tcp}     \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.21}     \PYG{c+c1}{\PYGZsh{} ssh from worker}
\PYG{l+m+mi}{8096}         \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{n}{Anywhere}          \PYG{c+c1}{\PYGZsh{} Emby HTTP}
\PYG{l+m+mi}{548}          \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.22}     \PYG{c+c1}{\PYGZsh{} Time Machine from mediator}
\PYG{l+m+mi}{427}          \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.22}     \PYG{c+c1}{\PYGZsh{} Time Machine from mediator}
\PYG{l+m+mi}{61208}        \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.0}\PYG{o}{/}\PYG{l+m+mi}{24}   \PYG{c+c1}{\PYGZsh{} Glances}
\PYG{l+m+mi}{22}\PYG{o}{/}\PYG{n}{tcp}       \PYG{n}{REJECT} \PYG{n}{IN}   \PYG{n}{Anywhere}          \PYG{c+c1}{\PYGZsh{} No SSH over normal port}
\PYG{l+m+mi}{2049}         \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20}     \PYG{c+c1}{\PYGZsh{} NFS from chell}
\PYG{l+m+mi}{111}          \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20}     \PYG{c+c1}{\PYGZsh{} NFS from chell}
\PYG{l+m+mi}{33333}        \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{13.20}     \PYG{c+c1}{\PYGZsh{} NFS from chell}
\PYG{l+m+mi}{5353} \PYG{p}{(}\PYG{n}{v6}\PYG{p}{)}    \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{n}{Anywhere} \PYG{p}{(}\PYG{n}{v6}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} Allow Zero Config}
\PYG{l+m+mi}{8096} \PYG{p}{(}\PYG{n}{v6}\PYG{p}{)}    \PYG{n}{ALLOW} \PYG{n}{IN}    \PYG{n}{Anywhere} \PYG{p}{(}\PYG{n}{v6}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} Emby HTTP}
\PYG{l+m+mi}{22}\PYG{o}{/}\PYG{n}{tcp} \PYG{p}{(}\PYG{n}{v6}\PYG{p}{)}  \PYG{n}{REJECT} \PYG{n}{IN}   \PYG{n}{Anywhere} \PYG{p}{(}\PYG{n}{v6}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} No SSH over normal port}
\end{sphinxVerbatim}

Administration stuff that might come in handy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{enable}          \PYG{c+c1}{\PYGZsh{} start the firewall}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{status} \PYG{n}{verbose}  \PYG{c+c1}{\PYGZsh{} what\PYGZsq{}s going on}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{app} \PYG{n+nb}{list}        \PYG{c+c1}{\PYGZsh{} who can pierce the firewall}
\PYG{n}{sudo} \PYG{n}{iptables} \PYG{o}{\PYGZhy{}}\PYG{n}{L}         \PYG{c+c1}{\PYGZsh{} list of rules}
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{disable}         \PYG{c+c1}{\PYGZsh{} stop the firewall}
\end{sphinxVerbatim}

Test with various machines to see if we can log in / do time machine / play videos.


\section{Links}
\label{\detokenize{firewall:links}}\begin{itemize}
\item {} 
\sphinxurl{https://www.cyberciti.biz/faq/how-to-setup-a-ufw-firewall-on-ubuntu-18-04-lts-server/}

\item {} 
\sphinxurl{https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-18-04}

\item {} 
\sphinxurl{https://help.ubuntu.com/community/UFW}

\item {} 
\sphinxurl{https://wiki.ubuntu.com/UncomplicatedFirewall}

\item {} 
\sphinxurl{http://manpages.ubuntu.com/manpages/bionic/en/man8/ufw.8.html}

\item {} 
\sphinxurl{https://wiki.debian.org/SecuringNFS}

\item {} 
\sphinxurl{https://serverfault.com/questions/377170/which-ports-do-i-need-to-open-in-the-firewall-to-use-nfs}-

\end{itemize}


\chapter{Tests}
\label{\detokenize{tests:tests}}\label{\detokenize{tests::doc}}
We use Lynis to look for security holes. Unfortunately, Ubuntu (again) contains
an old version. The following is how get the newest version:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dpkg} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{transport}\PYG{o}{\PYGZhy{}}\PYG{n}{https} \PYG{o}{\textbar{}} \PYG{n}{grep} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{status}
\end{sphinxVerbatim}

Shows us that the HTTPS transport is not installed. Do this with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{transport}\PYG{o}{\PYGZhy{}}\PYG{n}{https}
\end{sphinxVerbatim}

Now that we can use HTTPS we can install the program itself.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{adv} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{keyserver} \PYG{n}{keyserver}\PYG{o}{.}\PYG{n}{ubuntu}\PYG{o}{.}\PYG{n}{com} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{recv}\PYG{o}{\PYGZhy{}}\PYG{n}{keys} \PYG{n}{C80E383C3DE9F082E01391A0366C67DE91CA5D5F}
\PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{deb https://packages.cisofy.com/community/lynis/deb/ stable main}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\textbar{}} \PYG{n}{sudo} \PYG{n}{tee} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{sources}\PYG{o}{.}\PYG{n}{list}\PYG{o}{.}\PYG{n}{d}\PYG{o}{/}\PYG{n}{cisofy}\PYG{o}{\PYGZhy{}}\PYG{n}{lynis}\PYG{o}{.}\PYG{n}{list}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{update}
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{lynis}
\end{sphinxVerbatim}

Finally we’re ready to rock:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{lynis} \PYG{n}{audit} \PYG{n}{system} \PYG{o}{\textbar{}} \PYG{n}{less} \PYG{o}{\PYGZhy{}}\PYG{n}{R}
\end{sphinxVerbatim}

Walk through the output and figure out how to secure stuff.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cat} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{log}\PYG{o}{/}\PYG{n}{lynis}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\textbar{}} \PYG{n}{grep} \PYG{n}{Suggestion}
\end{sphinxVerbatim}


\section{Links}
\label{\detokenize{tests:links}}\begin{itemize}
\item {} 
\sphinxurl{https://packages.cisofy.com/community/\#debian-ubuntu}

\item {} 
\sphinxurl{https://www.digitalocean.com/community/tutorials/how-to-perform-security-audits-with-lynis-on-ubuntu-16-04}

\item {} 
\sphinxurl{https://cisofy.com/lynis/controls/}

\end{itemize}


\chapter{Speed}
\label{\detokenize{speed:speed}}\label{\detokenize{speed::doc}}
These are tests performed with a 1 GBit Ethernet connection. To test the
connection speed with iperf, install it first on both machines, chell and home.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{iperf3}
\end{sphinxVerbatim}

On home, start the server (\sphinxcode{\sphinxupquote{-f M}} gives format in MB/sec)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iperf3} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{M}
\end{sphinxVerbatim}

Now iperf will tell us which port it is listening at. We have to open the
firewall for testing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{allow} \PYG{l+m+mi}{5201}
\end{sphinxVerbatim}

On chell, start the client with :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iperf3} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{M} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{home}\PYG{o}{.}\PYG{n}{local}
\end{sphinxVerbatim}

This gives us \sphinxstylestrong{112 MB/sec} for memory-to-memory transfers, as expected over a
1 GBit Ethernet connection. Disk to memory test gives us the same thing, with
this on chell (the sender):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iperf3} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{M} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{home}\PYG{o}{.}\PYG{n}{local} \PYG{o}{\PYGZhy{}}\PYG{n}{i1} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{l+m+mi}{40}
\end{sphinxVerbatim}

For memory-to-disk, we start the server on home (with CWD as \sphinxcode{\sphinxupquote{/home/user1}} on an SSD)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iperf3} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{M} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{n}{test}
\end{sphinxVerbatim}

the receiving end. This gives us about \sphinxstylestrong{13.4 MB/sec} from memory to a SSD. We can
also test with storing the data on one of the ZFS pool datasets (currently 2 x
RaidZ three-disk VDEV) :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iperf3} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{M} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user1}\PYG{o}{/}\PYG{n}{test}
\end{sphinxVerbatim}

This gives us \sphinxstylestrong{9.7 MB/sec} from memory to HD RaidZ.

On home, remember to close the firewall again and to delete the test files,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{ufw} \PYG{n}{deny} \PYG{l+m+mi}{5201}
\PYG{n}{rm} \PYG{n}{test}
\PYG{n}{rm} \PYG{o}{/}\PYG{n}{tank}\PYG{o}{/}\PYG{n}{h\PYGZus{}user1}\PYG{o}{/}\PYG{n}{test}
\end{sphinxVerbatim}


\section{Summary}
\label{\detokenize{speed:summary}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Network
&\sphinxstyletheadfamily 
Speed
\\
\hline
mem-to-mem
&
1 GBit
&
112 MB/sec
\\
\hline
mem-to-ssd (ext4)
&
1 GBit
&
13.4 MB/sec
\\
\hline
mem-to-hd (ZFS)
&
1 GBit
&
9.7 MB/sec
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Links}
\label{\detokenize{speed:links}}\begin{itemize}
\item {} 
\sphinxurl{https://fasterdata.es.net/performance-testing/network-troubleshooting-tools/iperf/disk-testing-using-iperf/}

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}